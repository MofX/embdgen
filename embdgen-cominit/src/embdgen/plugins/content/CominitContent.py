# SPDX-License-Identifier: GPL-3.0-only

__version__ = "0.0.1"
from io import BufferedIOBase
from pathlib import Path
from dataclasses import dataclass
from typing import Optional
import math

from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey

from embdgen.core.utils.class_factory import Config
from embdgen.core.content.BinaryContent import BinaryContent
from embdgen.core.utils.SizeType import SizeType


@dataclass
class VerityMetadata:
    version: int
    data_block_size: int
    hash_block_size: int
    num_data_blocks: int
    hash_start_block: int
    algorithm: str
    digest: str
    salt: str

    @classmethod
    def from_file(cls, metadata_file: Path):
        data = {}
        with metadata_file.open("r", encoding="ascii") as file:
            for line in file:
                parts = line.split(':', 1)
                if len(parts) == 2:
                    data[parts[0].strip().lower()] = parts[1].strip()
        data_block_size = int(data['data block size'])
        hash_block_size = int(data['hash block size'])
        data_blocks = int(data['data blocks'])
        hash_start_block = math.ceil(data_blocks * data_block_size / hash_block_size)

        return VerityMetadata(
            int(data['hash type']),
            data_block_size,
            hash_block_size,
            data_blocks,
            hash_start_block,
            data["hash algorithm"],
            data["root hash"],
            data["salt"]
        )

    def serialize(self):
        return " ".join(map(str, [
            self.version,
            self.data_block_size,
            self.hash_block_size,
            self.num_data_blocks,
            self.hash_start_block,
            self.algorithm,
            self.digest,
            self.salt
        ])).encode()

@Config('content')
@Config('key')
@Config('readonly', optional=True)
@Config('dm_type')
@Config('filesystem')
@Config('metadata', optional=True)
class CominitContent(BinaryContent):
    """Cominit content

    Creates a partition with metadata for cominit

    There are currently two modes (``dm_type``) implemented:
    **plain** to create cominit metadata for a normal partition with the given filesystem or
    **verity** to create cominit metadata for a verity partition with the given filesystem and metadata.
    """
    CONTENT_TYPE = "cominit"
    METADATA_SIZE = SizeType(4096)

    content: BinaryContent
    """Content of the cominit partition"""

    dm_type: str
    """The type (either **plain** or **verity**)"""

    readonly: bool = False
    """Set to true, to make cominit mount the partition readonly (required for ``dm_type`` == **verity**)"""

    key: Path
    """Path to the private key for signing the cominit metadata"""

    filesystem: str
    """Type of the filesystem, that is contained in the partition and mounted by cominit"""

    metadata: Optional[Path] = None
    """If ``dm_type`` == **verity**, path to the metadata of the verity content
    (as generated by veritysetup or the VerityContent module)"""

    verity_metadata: Optional[VerityMetadata] = None

    def _parse_verity_metadata(self):
        self.verity_metadata = VerityMetadata.from_file(self.metadata)

    def prepare(self) -> None:
        if self.dm_type == 'verity':
            if not self.readonly:
                raise Exception("Verity must be readonly")
            if not self.metadata:
                raise Exception("Verity requires a metadata file")

        self.content.prepare()
        self.size = self.content.size + self.METADATA_SIZE

        if self.dm_type == 'verity':
            if not self.metadata:
                raise Exception("Metadata file not specified")
            if not self.metadata.exists():
                raise Exception(f"Metadata file {self.metadata} does not exist")
            self._parse_verity_metadata()

    def _create_sig(self, data: bytes):
        private_key = serialization.load_pem_private_key(self.key.read_bytes(), None)
        if not isinstance(private_key, RSAPrivateKey):
            raise Exception("Only RSA private keys are supported for cominit")
        return private_key.sign(data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=hashes.SHA256.digest_size
            ),
            hashes.SHA256()
        )

    def _create_metadata(self):
        meta = [
            "1",
            self.filesystem,
            "ro" if self.readonly else "rw",
            self.dm_type
        ]
        data = b" ".join(map(lambda x: x.encode(), meta))

        data += b"\xff"
        if self.dm_type == "verity":
            data += self.verity_metadata.serialize()
        data += b"\xff"
        # crypt table
        data += b"\0"
        data += self._create_sig(data)
        data += b"\0" * (self.METADATA_SIZE.bytes - len(data))

        return data

    def do_write(self, file: BufferedIOBase):
        self.content.write(file)
        file.write(self._create_metadata())

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.content})"
