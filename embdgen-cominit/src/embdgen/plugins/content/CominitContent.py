__version__ = "0.0.1"
from io import BufferedIOBase
from pathlib import Path
from dataclasses import dataclass
import math

from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization, hashes

from embdgen.core.utils.class_factory import Config
from embdgen.core.content.BinaryContent import BinaryContent
from embdgen.core.utils.SizeType import SizeType


@dataclass
class VerityMetadata:
    version: int
    data_block_size: int
    hash_block_size: int
    num_data_blocks: int
    hash_start_block: int
    algorithm: str
    digest: str
    salt: str

    @classmethod
    def from_file(cls, metadata_file: Path):
        data = {}
        with metadata_file.open("r", encoding="ascii") as file:
            for line in file:
                parts = line.split(':', 1)
                if len(parts) == 2:
                    data[parts[0].strip().lower()] = parts[1].strip()
        data_block_size = int(data['data block size'])
        hash_block_size = int(data['hash block size'])
        data_blocks = int(data['data blocks'])
        hash_start_block = math.ceil(data_blocks * data_block_size / hash_block_size)

        return VerityMetadata(
            int(data['hash type']),
            data_block_size,
            hash_block_size,
            data_blocks,
            hash_start_block,
            data["hash algorithm"],
            data["root hash"],
            data["salt"]
        )

    def serialize(self):
        return " ".join(map(str, [
            self.version,
            self.data_block_size,
            self.hash_block_size,
            self.num_data_blocks,
            self.hash_start_block,
            self.algorithm,
            self.digest,
            self.salt
        ])).encode()

@Config('content')
@Config('key')
@Config('readonly', optional=True)
@Config('dm_type')
@Config('filesystem')
@Config('metadata', optional=True)
class CominitContent(BinaryContent):
    """Cominit content
    
    Creates a partition with metadata for cominit

    There are currently two modes (``dm_type``) implemented:
    **plain** to create cominit metadata for a normal partition with the given filesystem or 
    **verity** to create cominit metadata for a verity partition with the given filesystem and metadata. 
    """
    CONTENT_TYPE = "cominit"
    METADATA_SIZE = SizeType(4096)

    content: BinaryContent
    """Content of the cominit partition"""
    dm_type: str = None
    """The type (either **plain** or **verity**)"""
    readonly: bool = False
    """Set to true, to make cominit mount the partition readonly (required for ``dm_type`` == **verity**)"""

    key: Path = None
    """Path to the private key for signing the cominit metadata"""

    filesystem: str = None
    """Type of the filesystem, that is contained in the partition and mounted by cominit"""
    metadata: Path = None
    """If ``dm_type`` == **verity**, path to the metadata of the verity content
    (as generated by veritysetup or the VerityContent module)"""

    verity_metadata: VerityMetadata = None

    def _parse_verity_metadata(self):
        self.verity_metadata = VerityMetadata.from_file(self.metadata)

    def prepare(self) -> None:
        if self.dm_type == 'verity':
            if not self.readonly:
                raise Exception("Verity must be readonly")
            if not self.metadata:
                raise Exception("Verity requires a metadata file")

        self.content.prepare()
        self.size = self.content.size + self.METADATA_SIZE

        if self.dm_type == 'verity':
            if not self.metadata.exists():
                raise Exception(f"Metadata file {self.metadata} does not exist")
            self._parse_verity_metadata()

    def _create_sig(self, data: bytes):
        private_key = serialization.load_pem_private_key(self.key.read_bytes(), None)
        return private_key.sign(data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.DIGEST_LENGTH
            ),
            hashes.SHA256()
        )

    def _create_metadata(self):
        meta = [
            "1",
            self.filesystem,
            "ro" if self.readonly else "rw",
            self.dm_type
        ]
        data = b" ".join(map(lambda x: x.encode(), meta))

        data += b"\xff"
        if self.dm_type == "verity":
            data += self.verity_metadata.serialize()
        data += b"\xff"
        # crypt table
        data += b"\0"
        data += self._create_sig(data)
        data += b"\0" * (self.METADATA_SIZE.bytes - len(data))

        return data

    def do_write(self, file: BufferedIOBase):
        self.content.write(file)
        file.write(self._create_metadata())

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({self.content})"
